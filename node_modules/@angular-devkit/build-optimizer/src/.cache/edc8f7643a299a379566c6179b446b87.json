{"remainingRequest":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\chart.js\\src\\core\\core.animation.js","dependencies":[{"path":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\chart.js\\src\\core\\core.animation.js","mtime":1534453529624},{"path":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1534453527822},{"path":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1534453515782}],"contextDependencies":[],"result":["/* global window: false */\r\n'use strict';\r\n\r\nvar defaults = require('./core.defaults');\r\nvar Element = require('./core.element');\r\nvar helpers = require('../helpers/index');\r\n\r\ndefaults._set('global', {\r\n\tanimation: {\r\n\t\tduration: 1000,\r\n\t\teasing: 'easeOutQuart',\r\n\t\tonProgress: helpers.noop,\r\n\t\tonComplete: helpers.noop\r\n\t}\r\n});\r\n\r\nmodule.exports = function(Chart) {\r\n\r\n\tChart.Animation = Element.extend({\r\n\t\tchart: null, // the animation associated chart instance\r\n\t\tcurrentStep: 0, // the current animation step\r\n\t\tnumSteps: 60, // default number of steps\r\n\t\teasing: '', // the easing to use for this animation\r\n\t\trender: null, // render function used by the animation service\r\n\r\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\r\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\r\n\t});\r\n\r\n\tChart.animationService = {\r\n\t\tframeDuration: 17,\r\n\t\tanimations: [],\r\n\t\tdropFrames: 0,\r\n\t\trequest: null,\r\n\r\n\t\t/**\r\n\t\t * @param {Chart} chart - The chart to animate.\r\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\r\n\t\t * @param {Number} duration - The animation duration in ms.\r\n\t\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\r\n\t\t */\r\n\t\taddAnimation: function(chart, animation, duration, lazy) {\r\n\t\t\tvar animations = this.animations;\r\n\t\t\tvar i, ilen;\r\n\r\n\t\t\tanimation.chart = chart;\r\n\r\n\t\t\tif (!lazy) {\r\n\t\t\t\tchart.animating = true;\r\n\t\t\t}\r\n\r\n\t\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\r\n\t\t\t\tif (animations[i].chart === chart) {\r\n\t\t\t\t\tanimations[i] = animation;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tanimations.push(animation);\r\n\r\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\r\n\t\t\tif (animations.length === 1) {\r\n\t\t\t\tthis.requestAnimationFrame();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcancelAnimation: function(chart) {\r\n\t\t\tvar index = helpers.findIndex(this.animations, function(animation) {\r\n\t\t\t\treturn animation.chart === chart;\r\n\t\t\t});\r\n\r\n\t\t\tif (index !== -1) {\r\n\t\t\t\tthis.animations.splice(index, 1);\r\n\t\t\t\tchart.animating = false;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\trequestAnimationFrame: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tif (me.request === null) {\r\n\t\t\t\t// Skip animation frame requests until the active one is executed.\r\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\r\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\r\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\r\n\t\t\t\t\tme.request = null;\r\n\t\t\t\t\tme.startDigest();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tstartDigest: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar startTime = Date.now();\r\n\t\t\tvar framesToDrop = 0;\r\n\r\n\t\t\tif (me.dropFrames > 1) {\r\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\r\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\r\n\t\t\t}\r\n\r\n\t\t\tme.advance(1 + framesToDrop);\r\n\r\n\t\t\tvar endTime = Date.now();\r\n\r\n\t\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\r\n\r\n\t\t\t// Do we have more stuff to animate?\r\n\t\t\tif (me.animations.length > 0) {\r\n\t\t\t\tme.requestAnimationFrame();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tadvance: function(count) {\r\n\t\t\tvar animations = this.animations;\r\n\t\t\tvar animation, chart;\r\n\t\t\tvar i = 0;\r\n\r\n\t\t\twhile (i < animations.length) {\r\n\t\t\t\tanimation = animations[i];\r\n\t\t\t\tchart = animation.chart;\r\n\r\n\t\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\r\n\t\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\r\n\r\n\t\t\t\thelpers.callback(animation.render, [chart, animation], chart);\r\n\t\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\r\n\r\n\t\t\t\tif (animation.currentStep >= animation.numSteps) {\r\n\t\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\r\n\t\t\t\t\tchart.animating = false;\r\n\t\t\t\t\tanimations.splice(i, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t++i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Provided for backward compatibility, use Chart.Animation instead\r\n\t * @prop Chart.Animation#animationObject\r\n\t * @deprecated since version 2.6.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\tObject.defineProperty(Chart.Animation.prototype, 'animationObject', {\r\n\t\tget: function() {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n\r\n\t/**\r\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\r\n\t * @prop Chart.Animation#chartInstance\r\n\t * @deprecated since version 2.6.0\r\n\t * @todo remove at version 3\r\n\t */\r\n\tObject.defineProperty(Chart.Animation.prototype, 'chartInstance', {\r\n\t\tget: function() {\r\n\t\t\treturn this.chart;\r\n\t\t},\r\n\t\tset: function(value) {\r\n\t\t\tthis.chart = value;\r\n\t\t}\r\n\t});\r\n\r\n};\r\n",null]}