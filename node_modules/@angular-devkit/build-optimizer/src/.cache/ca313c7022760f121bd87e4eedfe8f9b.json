{"remainingRequest":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\chart.js\\src\\controllers\\controller.bar.js","dependencies":[{"path":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\chart.js\\src\\controllers\\controller.bar.js","mtime":1534453529613},{"path":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1534453527822},{"path":"C:\\work\\project\\Quick-Select-Angular-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1534453515782}],"contextDependencies":[],"result":["'use strict';\r\n\r\nvar defaults = require('../core/core.defaults');\r\nvar elements = require('../elements/index');\r\nvar helpers = require('../helpers/index');\r\n\r\ndefaults._set('bar', {\r\n\thover: {\r\n\t\tmode: 'label'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'category',\r\n\r\n\t\t\t// Specific to Bar Controller\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage: 0.9,\r\n\r\n\t\t\t// offset settings\r\n\t\t\toffset: true,\r\n\r\n\t\t\t// grid line settings\r\n\t\t\tgridLines: {\r\n\t\t\t\toffsetGridLines: true\r\n\t\t\t}\r\n\t\t}],\r\n\r\n\t\tyAxes: [{\r\n\t\t\ttype: 'linear'\r\n\t\t}]\r\n\t}\r\n});\r\n\r\ndefaults._set('horizontalBar', {\r\n\thover: {\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t},\r\n\r\n\tscales: {\r\n\t\txAxes: [{\r\n\t\t\ttype: 'linear',\r\n\t\t\tposition: 'bottom'\r\n\t\t}],\r\n\r\n\t\tyAxes: [{\r\n\t\t\tposition: 'left',\r\n\t\t\ttype: 'category',\r\n\r\n\t\t\t// Specific to Horizontal Bar Controller\r\n\t\t\tcategoryPercentage: 0.8,\r\n\t\t\tbarPercentage: 0.9,\r\n\r\n\t\t\t// offset settings\r\n\t\t\toffset: true,\r\n\r\n\t\t\t// grid line settings\r\n\t\t\tgridLines: {\r\n\t\t\t\toffsetGridLines: true\r\n\t\t\t}\r\n\t\t}]\r\n\t},\r\n\r\n\telements: {\r\n\t\trectangle: {\r\n\t\t\tborderSkipped: 'left'\r\n\t\t}\r\n\t},\r\n\r\n\ttooltips: {\r\n\t\tcallbacks: {\r\n\t\t\ttitle: function(item, data) {\r\n\t\t\t\t// Pick first xLabel for now\r\n\t\t\t\tvar title = '';\r\n\r\n\t\t\t\tif (item.length > 0) {\r\n\t\t\t\t\tif (item[0].yLabel) {\r\n\t\t\t\t\t\ttitle = item[0].yLabel;\r\n\t\t\t\t\t} else if (data.labels.length > 0 && item[0].index < data.labels.length) {\r\n\t\t\t\t\t\ttitle = data.labels[item[0].index];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn title;\r\n\t\t\t},\r\n\r\n\t\t\tlabel: function(item, data) {\r\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\r\n\t\t\t\treturn datasetLabel + ': ' + item.xLabel;\r\n\t\t\t}\r\n\t\t},\r\n\t\tmode: 'index',\r\n\t\taxis: 'y'\r\n\t}\r\n});\r\n\r\n/**\r\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\r\n * @private\r\n */\r\nfunction computeMinSampleSize(scale, pixels) {\r\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\r\n\tvar ticks = scale.getTicks();\r\n\tvar prev, curr, i, ilen;\r\n\r\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\r\n\t\tmin = Math.min(min, pixels[i] - pixels[i - 1]);\r\n\t}\r\n\r\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n\t\tcurr = scale.getPixelForTick(i);\r\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\r\n\t\tprev = curr;\r\n\t}\r\n\r\n\treturn min;\r\n}\r\n\r\n/**\r\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\r\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\r\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\r\n * @private\r\n */\r\nfunction computeFitCategoryTraits(index, ruler, options) {\r\n\tvar thickness = options.barThickness;\r\n\tvar count = ruler.stackCount;\r\n\tvar curr = ruler.pixels[index];\r\n\tvar size, ratio;\r\n\r\n\tif (helpers.isNullOrUndef(thickness)) {\r\n\t\tsize = ruler.min * options.categoryPercentage;\r\n\t\tratio = options.barPercentage;\r\n\t} else {\r\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\r\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\r\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\r\n\t\tsize = thickness * count;\r\n\t\tratio = 1;\r\n\t}\r\n\r\n\treturn {\r\n\t\tchunk: size / count,\r\n\t\tratio: ratio,\r\n\t\tstart: curr - (size / 2)\r\n\t};\r\n}\r\n\r\n/**\r\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\r\n * percentage options are 1), based on the previous and following categories. This mode\r\n * generates bars with different widths when data are not evenly spaced.\r\n * @private\r\n */\r\nfunction computeFlexCategoryTraits(index, ruler, options) {\r\n\tvar pixels = ruler.pixels;\r\n\tvar curr = pixels[index];\r\n\tvar prev = index > 0 ? pixels[index - 1] : null;\r\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n\tvar percent = options.categoryPercentage;\r\n\tvar start, size;\r\n\r\n\tif (prev === null) {\r\n\t\t// first data: its size is double based on the next point or,\r\n\t\t// if it's also the last data, we use the scale end extremity.\r\n\t\tprev = curr - (next === null ? ruler.end - curr : next - curr);\r\n\t}\r\n\r\n\tif (next === null) {\r\n\t\t// last data: its size is also double based on the previous point.\r\n\t\tnext = curr + curr - prev;\r\n\t}\r\n\r\n\tstart = curr - ((curr - prev) / 2) * percent;\r\n\tsize = ((next - prev) / 2) * percent;\r\n\r\n\treturn {\r\n\t\tchunk: size / ruler.stackCount,\r\n\t\tratio: options.barPercentage,\r\n\t\tstart: start\r\n\t};\r\n}\r\n\r\nmodule.exports = function(Chart) {\r\n\r\n\tChart.controllers.bar = Chart.DatasetController.extend({\r\n\r\n\t\tdataElementType: elements.Rectangle,\r\n\r\n\t\tinitialize: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar meta;\r\n\r\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\r\n\r\n\t\t\tmeta = me.getMeta();\r\n\t\t\tmeta.stack = me.getDataset().stack;\r\n\t\t\tmeta.bar = true;\r\n\t\t},\r\n\r\n\t\tupdate: function(reset) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar rects = me.getMeta().data;\r\n\t\t\tvar i, ilen;\r\n\r\n\t\t\tme._ruler = me.getRuler();\r\n\r\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\r\n\t\t\t\tme.updateElement(rects[i], i, reset);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdateElement: function(rectangle, index, reset) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar meta = me.getMeta();\r\n\t\t\tvar dataset = me.getDataset();\r\n\t\t\tvar custom = rectangle.custom || {};\r\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\r\n\r\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\r\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\r\n\t\t\trectangle._datasetIndex = me.index;\r\n\t\t\trectangle._index = index;\r\n\r\n\t\t\trectangle._model = {\r\n\t\t\t\tdatasetLabel: dataset.label,\r\n\t\t\t\tlabel: chart.data.labels[index],\r\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\r\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\r\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\r\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\r\n\t\t\t};\r\n\r\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\r\n\r\n\t\t\trectangle.pivot();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar model = rectangle._model;\r\n\t\t\tvar vscale = me.getValueScale();\r\n\t\t\tvar base = vscale.getBasePixel();\r\n\t\t\tvar horizontal = vscale.isHorizontal();\r\n\t\t\tvar ruler = me._ruler || me.getRuler();\r\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\r\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\r\n\r\n\t\t\tmodel.horizontal = horizontal;\r\n\t\t\tmodel.base = reset ? base : vpixels.base;\r\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\r\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\r\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\r\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetValueScaleId: function() {\r\n\t\t\treturn this.getMeta().yAxisID;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetIndexScaleId: function() {\r\n\t\t\treturn this.getMeta().xAxisID;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetValueScale: function() {\r\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetIndexScale: function() {\r\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the stacks based on groups and bar visibility.\r\n\t\t * @param {Number} [last] - The dataset index\r\n\t\t * @returns {Array} The stack list\r\n\t\t * @private\r\n\t\t */\r\n\t\t_getStacks: function(last) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar scale = me.getIndexScale();\r\n\t\t\tvar stacked = scale.options.stacked;\r\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\r\n\t\t\tvar stacks = [];\r\n\t\t\tvar i, meta;\r\n\r\n\t\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\r\n\t\t\t\t\t(stacked === false ||\r\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\r\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\r\n\t\t\t\t\tstacks.push(meta.stack);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn stacks;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetStackCount: function() {\r\n\t\t\treturn this._getStacks().length;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\r\n\t\t * @param {Number} [datasetIndex] - The dataset index\r\n\t\t * @param {String} [name] - The stack name to find\r\n\t\t * @returns {Number} The stack index\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetStackIndex: function(datasetIndex, name) {\r\n\t\t\tvar stacks = this._getStacks(datasetIndex);\r\n\t\t\tvar index = (name !== undefined)\r\n\t\t\t\t? stacks.indexOf(name)\r\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\r\n\r\n\t\t\treturn (index === -1)\r\n\t\t\t\t? stacks.length - 1\r\n\t\t\t\t: index;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetRuler: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar scale = me.getIndexScale();\r\n\t\t\tvar stackCount = me.getStackCount();\r\n\t\t\tvar datasetIndex = me.index;\r\n\t\t\tvar isHorizontal = scale.isHorizontal();\r\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\r\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\r\n\t\t\tvar pixels = [];\r\n\t\t\tvar i, ilen, min;\r\n\r\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\r\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\r\n\t\t\t}\r\n\r\n\t\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\r\n\t\t\t\t? computeMinSampleSize(scale, pixels)\r\n\t\t\t\t: -1;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tmin: min,\r\n\t\t\t\tpixels: pixels,\r\n\t\t\t\tstart: start,\r\n\t\t\t\tend: end,\r\n\t\t\t\tstackCount: stackCount,\r\n\t\t\t\tscale: scale\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Note: pixel values are not clamped to the scale area.\r\n\t\t * @private\r\n\t\t */\r\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar meta = me.getMeta();\r\n\t\t\tvar scale = me.getValueScale();\r\n\t\t\tvar datasets = chart.data.datasets;\r\n\t\t\tvar value = scale.getRightValue(datasets[datasetIndex].data[index]);\r\n\t\t\tvar stacked = scale.options.stacked;\r\n\t\t\tvar stack = meta.stack;\r\n\t\t\tvar start = 0;\r\n\t\t\tvar i, imeta, ivalue, base, head, size;\r\n\r\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\r\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\r\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\r\n\r\n\t\t\t\t\tif (imeta.bar &&\r\n\t\t\t\t\t\timeta.stack === stack &&\r\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\r\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\r\n\r\n\t\t\t\t\t\tivalue = scale.getRightValue(datasets[i].data[index]);\r\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\r\n\t\t\t\t\t\t\tstart += ivalue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbase = scale.getPixelForValue(start);\r\n\t\t\thead = scale.getPixelForValue(start + value);\r\n\t\t\tsize = (head - base) / 2;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tsize: size,\r\n\t\t\t\tbase: base,\r\n\t\t\t\thead: head,\r\n\t\t\t\tcenter: head + size / 2\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar options = ruler.scale.options;\r\n\t\t\tvar range = options.barThickness === 'flex'\r\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\r\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\r\n\r\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\r\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n\t\t\tvar size = Math.min(\r\n\t\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\r\n\t\t\t\trange.chunk * range.ratio);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tbase: center - size / 2,\r\n\t\t\t\thead: center + size / 2,\r\n\t\t\t\tcenter: center,\r\n\t\t\t\tsize: size\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tdraw: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar scale = me.getValueScale();\r\n\t\t\tvar rects = me.getMeta().data;\r\n\t\t\tvar dataset = me.getDataset();\r\n\t\t\tvar ilen = rects.length;\r\n\t\t\tvar i = 0;\r\n\r\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\r\n\r\n\t\t\tfor (; i < ilen; ++i) {\r\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\r\n\t\t\t\t\trects[i].draw();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\r\n\t\t},\r\n\r\n\t\tsetHoverStyle: function(rectangle) {\r\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\r\n\t\t\tvar index = rectangle._index;\r\n\t\t\tvar custom = rectangle.custom || {};\r\n\t\t\tvar model = rectangle._model;\r\n\r\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\r\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\r\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\r\n\t\t},\r\n\r\n\t\tremoveHoverStyle: function(rectangle) {\r\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\r\n\t\t\tvar index = rectangle._index;\r\n\t\t\tvar custom = rectangle.custom || {};\r\n\t\t\tvar model = rectangle._model;\r\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\r\n\r\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\r\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\r\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\r\n\t\t}\r\n\t});\r\n\r\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetValueScaleId: function() {\r\n\t\t\treturn this.getMeta().xAxisID;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\tgetIndexScaleId: function() {\r\n\t\t\treturn this.getMeta().yAxisID;\r\n\t\t}\r\n\t});\r\n};\r\n",null]}